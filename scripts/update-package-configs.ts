import * as fs from 'fs';
import * as path from 'path';
import * as mkdirp from 'mkdirp';
import { packages } from '../workspace-packages';

const TSCONFIG_COMMENT = `// Don't edit this file directly. It is generated by /scripts/update-package-configs.ts\n\n`;

const packagesRoot = path.join(__dirname, '..', 'packages');
interface PackageJSON {
  name: string;
  dependencies: { [packageName: string]: string };
  devDependencies: { [packageName: string]: string };
}
const packageJSONMap: Map<string, PackageJSON> = new Map();
const packageDirnameMap: Map<string, string> = new Map();
const internalDependencyMap: Map<string, string[]> = new Map();

// collect package json for all packages
packages.forEach(pkg => {
  const packageJSONPath = path.join(packagesRoot, pkg.name, 'package.json');
  if (!fs.existsSync(packageJSONPath)) {
    console.error();
    console.error(`Could not find package.json: ${packageJSONPath}`);
    console.error();
    process.exit(1);
  }

  const packageJSONData = JSON.parse(fs.readFileSync(packageJSONPath).toString());
  const packageName = packageJSONData.name;
  packageDirnameMap.set(packageName, pkg.name);
  packageJSONMap.set(packageName, packageJSONData);
});

// collect initial cross package dependencies info
packageDirnameMap.forEach((_packageDirname, packageName) => {
  const { dependencies, devDependencies } = packageJSONMap.get(packageName)!;

  const internalDependencies = [
    ...(dependencies ? Object.keys(dependencies) : []),
    ...(devDependencies ? Object.keys(devDependencies) : []),
  ].filter(dep => packageDirnameMap.has(dep));

  internalDependencyMap.set(packageName, internalDependencies);
});

function resolveInternalDependencies(dependencies: string[]): string[] {
  const childDeps = [];

  for (const idep of dependencies) {
    const deps = internalDependencyMap.get(idep)!;
    const res = resolveInternalDependencies(deps);
    for (const jdep of res) {
      childDeps.push(jdep);
    }
  }
  const resolved = childDeps.concat(dependencies);
  // remove all duplicated after the first appearance
  return resolved.filter((item, idx) => resolved.indexOf(item) === idx);
}

packageDirnameMap.forEach((packageDirname, packageName) => {
  const pkg = packages.find(pkg => pkg.name === packageDirname)!;
  const pkgDir = path.join(packagesRoot, packageDirname);
  const tsconfigPath = path.join(pkgDir, 'tsconfig.json');

  const internalDependencies = resolveInternalDependencies(internalDependencyMap.get(packageName)!);
  const tsconfigData = {
    extends: `../../tsconfig.${pkg.environment === 'browser' ? 'browser' : 'node'}-base.json`,
    compilerOptions: {
      outDir: './dist',
      module: pkg.environment === 'browser' ? 'ESNext' : 'commonjs',
      rootDir: './src',
      composite: true,
      allowJs: true,
      checkJs: pkg.type === 'js' ? true : undefined,
      emitDeclarationOnly: pkg.type === 'js' ? true : undefined,
    },
    references: internalDependencies.map(dep => {
      return { path: `../${packageDirnameMap.get(dep)}/tsconfig.json` };
    }),
    include: ['src'],
    exclude: ['src/browser', 'tests', 'dist'],
  };
  fs.writeFileSync(tsconfigPath, TSCONFIG_COMMENT + JSON.stringify(tsconfigData, null, '  '));

  if (pkg.environment === 'mixed') {
    const browserTsconfig = {
      ...tsconfigData,
      extends: '../../../../tsconfig.browser-base.json',
      compilerOptions: {
        ...tsconfigData.compilerOptions,
        outDir: '.',
        module: 'ESNext',
        rootDir: '.',
      },
      references: tsconfigData.references.map(ref => `../../${ref}`),
      include: ['.'],
    };
    const browserDir = path.join(pkgDir, 'src', 'browser');
    const browserTsConfigPath = path.join(browserDir, 'tsconfig.json');
    mkdirp.sync(browserDir);
    fs.writeFileSync(
      browserTsConfigPath,
      TSCONFIG_COMMENT + JSON.stringify(browserTsconfig, null, '  '),
    );
  }
});

const projectLevelTsconfigPath = path.join(__dirname, '..', 'tsconfig.json');

const projectLevelTsconfigData = {
  files: [],
  references: resolveInternalDependencies(Array.from(packageDirnameMap.keys())).map(
    packageName => ({
      path: `./packages/${packageDirnameMap.get(packageName)}/tsconfig.json`,
    }),
  ),
};

fs.writeFileSync(
  projectLevelTsconfigPath,
  TSCONFIG_COMMENT + JSON.stringify(projectLevelTsconfigData, null, '  '),
);
